# فصل ۹ – مجوزها

---

## مقدمه

یکی از پایه‌ای‌ترین تفاوت‌های سیستم‌عامل‌های شبه‌یونیکس با پلتفرم‌های دسکتاپ خانگی، مدل دقیق کنترل دسترسی آن‌ها است.
هر فایل، پوشه و فرایند دارای مالکیت و مجوزهایی است که تعیین می‌کند چه کسانی می‌توانند آن را بخوانند، تغییر دهند یا اجرا کنند.
بدون شناخت این مفاهیم نه‌تنها امکان مدیریت سامانه‌های چندکاربره دشوار می‌شود، بلکه ممکن است ناخواسته به امنیت خود آسیب بزنیم.

در این فصل می‌آموزیم:

* ساختار مالکیت فایل‌ها در لینوکس چگونه است و چه نقشی برای کاربر و گروه تعریف می‌شود.
* مجوزهای خواندن، نوشتن و اجرا چه معنایی دارند و چگونه برای فایل‌ها و دایرکتوری‌ها متفاوت تفسیر می‌شوند.
* چگونه با دستور `chmod`، هم به روش نمادین و هم به روش عددی، مجوزها را تغییر دهیم.
* کاربردهای دستورهای `chown` و `chgrp` برای تغییر مالک و گروه.
* مفهوم `umask` و تأثیر آن بر مجوزهای پیش‌فرض.
* نحوهٔ استفاده از `sudo` و `su` برای اجرای دستورات با امتیازات دیگر حساب‌ها.

---

## مالکیت فایل‌ها

هر شیء در سیستم‌فایل دو نوع مالک دارد: «مالک کاربر» و «مالک گروه».
کاربر مالک معمولاً شخصی است که فایل را ایجاد کرده است، در حالی که گروه مالک به مجموعه‌ای از کاربران اشاره دارد که می‌توانند مجوزهای مشترک داشته باشند.

برای مشاهدهٔ مالکیت و مجوزها از `ls -l` استفاده کنید:

```bash
ls -l /etc/passwd
```

خروجی نمونه:

```
-rw-r--r-- 1 root root 2761 Jan 13 09:32 /etc/passwd
```

ستون چهارم و پنجم نام کاربر و گروه مالک را نشان می‌دهند (در این مثال هر دو `root`).
اولین مجموعه از کاراکترها (`-rw-r--r--`) نمایانگر نوع فایل و مجوزها است که در ادامه بررسی می‌کنیم.

### تغییر مالکیت

فقط کاربر ریشه یا مالک فایل (در برخی شرایط) می‌تواند مالکیت را تغییر دهد.
برای تغییر مالک از `chown` استفاده می‌کنیم:

```bash
sudo chown ali document.txt      # انتقال مالکیت فایل به کاربر «ali»
sudo chown ali:users document.txt # تغییر مالک کاربر و گروه به‌طور هم‌زمان
```

اگر فقط بخواهیم گروه را عوض کنیم، دستور `chgrp` مناسب است:

```bash
sudo chgrp developers project/
```

در مثال بالا، گروه مالک پوشهٔ `project/` به `developers` تغییر می‌کند.
به یاد داشته باشید که تغییر مالکیت روی پوشه‌ها می‌تواند دسترسی به محتویات را نیز تحت تأثیر قرار دهد.

---

## مجوزهای دسترسی

مجوزهای کلاسیک یونیکس سه نوع‌اند: خواندن (`r`)، نوشتن (`w`) و اجرا (`x`).
این مجوزها برای سه دستهٔ کاربر تعیین می‌شوند:

1. **مالک (user)**
2. **گروه (group)**
3. **سایرین (others)**

در رشتهٔ مجوزها مانند `-rwxr-xr--`، کاراکتر نخست نوع فایل است (`-` برای فایل معمولی، `d` برای دایرکتوری، `l` برای پیوند نمادین و ...)، سه کاراکتر بعدی مجوزهای مالک، سپس سه کاراکتر بعدی مجوزهای گروه و در نهایت سه کاراکتر پایانی مجوزهای سایر کاربران هستند.

### معنای مجوزها برای فایل‌ها و پوشه‌ها

* **خواندن (`r`)**: برای فایل یعنی امکان مشاهدهٔ محتوا. برای دایرکتوری یعنی امکان فهرست کردن نام فایل‌های داخل آن.
* **نوشتن (`w`)**: برای فایل یعنی امکان تغییر محتوا یا حذف آن. برای دایرکتوری یعنی توانایی ایجاد، حذف یا تغییر نام آیتم‌های داخل.
* **اجرا (`x`)**: برای فایل یعنی می‌توان آن را به عنوان برنامه یا اسکریپت اجرا کرد. برای دایرکتوری یعنی امکان ورود (cd) و دسترسی به آیتم‌ها با مسیر کامل.

اگر دایرکتوری مجوز خواندن نداشته باشد اما `x` داشته باشد، می‌توانیم به فایل‌های آن دسترسی داشته باشیم به شرطی که نام دقیق‌شان را بدانیم.

### بیت‌های ویژه

علاوه بر `rwx`، سه پرچم خاص نیز وجود دارد:

* **setuid (`s` در ستون مالک)**: اگر روی فایل اجرایی تنظیم شود، برنامه با امتیازهای مالک اجرا می‌شود. نمونهٔ مشهور: `/usr/bin/passwd` که با امتیاز ریشه رمز عبور را تغییر می‌دهد.
* **setgid (`s` در ستون گروه)**: برای فایل‌های اجرایی مشابه setuid است اما امتیازهای گروه را به ارث می‌دهد. روی دایرکتوری‌ها باعث می‌شود فایل‌های جدید ساخته‌شده در آن گروه مالک دایرکتوری را بگیرند.
* **sticky (`t` در ستون سایرین)**: عموماً روی دایرکتوری‌هایی مانند `/tmp` قرار دارد و باعث می‌شود کاربران تنها بتوانند فایل‌های خود را حذف کنند، حتی اگر مجوز نوشتن عمومی وجود داشته باشد.

برای نمایش عددی این بیت‌ها از یک رقم اضافی در سمت چپ استفاده می‌شود (۰ تا ۷).

---

## تغییر مجوزها با `chmod`

دستور `chmod` دو روش اصلی برای تعیین مجوز دارد: نمادین و عددی.

### حالت نمادین

در این نگارش از حروف `u`, `g`, `o`, `a` برای اشاره به مالک، گروه، سایرین و همه استفاده می‌شود.
عملگرهای `+`, `-`, `=` نیز برای افزودن، حذف یا تعیین دقیق مجوزها به کار می‌روند.

مثال‌ها:

```bash
chmod u+x script.sh        # افزودن مجوز اجرا برای مالک
chmod go-w report.txt      # حذف مجوز نوشتن از گروه و سایرین
chmod a=r file.txt         # تنظیم مجوز خواندن برای همه و حذف سایر مجوزها
chmod u+s /usr/local/bin/app  # فعال کردن بیت setuid
```

می‌توان دستورات را با کاما ترکیب کرد:

```bash
chmod u=rw,go=r shared.conf
```

### حالت عددی

در روش عددی هر مجموعهٔ مجوز به صورت یک عدد پایهٔ ۸ بیان می‌شود.
ارزش‌های پایه عبارت‌اند از: خواندن = ۴، نوشتن = ۲، اجرا = ۱.

برای نمونه، `rwx` برابر ۷ (۴+۲+۱)، `rw-` برابر ۶ (۴+۲)، و `r-x` برابر ۵ (۴+۱) است.

دستور زیر مجوزهای فایل را به `-rwxr-x---` تغییر می‌دهد:

```bash
chmod 750 script.sh
```

اگر بخواهیم بیت‌های ویژه را هم تنظیم کنیم، عدد چهارمی در ابتدای توالی اضافه می‌کنیم:

* ۴ برای setuid
* ۲ برای setgid
* ۱ برای sticky

مثلاً `chmod 4755 program` بیت setuid را همراه با مجوز `755` فعال می‌کند.

---

## مجوزهای پیش‌فرض و `umask`

هنگامی که برنامه‌ای فایل جدیدی می‌سازد، مجوزهای پیش‌فرض بر اساس «ماسک کاربر» یا `umask` تعیین می‌شود.
`umask` بیت‌هایی را مشخص می‌کند که باید از مجوزهای پیشنهادی حذف شوند.

برای مشاهدهٔ مقدار فعلی:

```bash
umask
```

به طور معمول مقدار `022` یا `002` دیده می‌شود.
سیستم فایل معمولاً فایل‌های جدید را با مجوز پایهٔ `666` (rw برای همه) و دایرکتوری‌های جدید را با `777` (rwx برای همه) پیشنهاد می‌دهد.
`umask` این مقادیر را کاهیده و نتیجهٔ نهایی را تعیین می‌کند.

مثلاً اگر `umask` برابر `022` باشد:

* فایل جدید: 666 - 022 = 644 → `rw-r--r--`
* دایرکتوری جدید: 777 - 022 = 755 → `rwxr-xr-x`

برای تغییر موقتی `umask` در نشست فعلی:

```bash
umask 027
```

برای اعمال دائم آن را در فایل پیکربندی شل مانند `~/.bashrc` یا `/etc/profile` قرار دهید.

---

## کار با امتیازات ریشه: `su` و `sudo`

بسیاری از عملیات مدیریتی نیاز به امتیازهای بالاتر از کاربر معمولی دارند.
در لینوکس دو ابزار اصلی برای این منظور استفاده می‌شود: `su` و `sudo`.

### `su`

دستور `su` (switch user) پوسته‌ای جدید با هویت کاربر دیگر – معمولاً ریشه – باز می‌کند.

```bash
su -
```

گزینهٔ `-` باعث می‌شود پوستهٔ جدید محیط ورود کامل کاربر هدف را بارگذاری کند.
برای خروج از نشست `su` کافی است `exit` بزنید.

### `sudo`

`sudo` اجازه می‌دهد یک دستور منفرد را با امتیاز کاربر دیگری اجرا کنیم، بدون آن‌که وارد پوستهٔ او شویم.
اغلب سیستم‌ها `sudo` را برای کاربران مجاز پیکربندی می‌کنند تا پس از وارد کردن رمز عبور خود بتوانند عملیات مدیریتی انجام دهند.

```bash
sudo apt update
sudo systemctl restart nginx
```

قوانین `sudo` در فایل `/etc/sudoers` و دایرکتوری `/etc/sudoers.d/` تعریف می‌شوند و باید فقط با دستور `visudo` ویرایش شوند تا خطاهای نحوی جلوگیری شود.

برای مشاهدهٔ دستورات مجاز، از `sudo -l` استفاده کنید.

### بهترین شیوه‌ها

* فقط مجوزهای لازم را اعطا کنید و از دادن دسترسی کامل به همه کاربران بپرهیزید.
* برای کارهای روزمره از حساب معمولی استفاده کنید و تنها در زمان نیاز از `sudo` کمک بگیرید.
* تاریخچهٔ دستورات اجراشده با `sudo` در فایل‌های لاگ ذخیره می‌شود که در صورت نیاز برای بررسی امنیتی قابل استفاده است.

---

## نمونهٔ عملی: مدیریت پوشهٔ اشتراکی

فرض کنید باید پوشه‌ای مشترک برای تیم توسعه ایجاد کنیم تا اعضا بتوانند فایل‌های پروژه را تبادل کنند.
می‌خواهیم:

1. گروهی به نام `devteam` بسازیم.
2. مالکیت پوشهٔ `/srv/devshare` را به کاربر مسئول و گروه `devteam` بدهیم.
3. تضمین کنیم هر فایل جدیدی که در پوشه ایجاد می‌شود به طور خودکار به گروه `devteam` تعلق داشته باشد و سایر اعضا بتوانند آن را بخوانند و بنویسند.

مراحل:

```bash
sudo groupadd devteam
sudo mkdir -p /srv/devshare
sudo chown lead:devteam /srv/devshare
sudo chmod 2775 /srv/devshare
```

مجوز `2775` چه معنایی دارد؟

* رقم نخست `2` بیت setgid را فعال می‌کند تا فایل‌های جدید گروه دایرکتوری را به ارث ببرند.
* ارقام بعدی `775` یعنی مالک (`lead`) تمام مجوزها را دارد، اعضای گروه `devteam` نیز مجوز خواندن/نوشتن/اجرا دارند و سایر کاربران فقط می‌توانند بخوانند و وارد دایرکتوری شوند.

اگر می‌خواهیم کاربران نتوانند فایل‌های یکدیگر را حذف کنند، می‌توانیم بیت sticky را نیز فعال کنیم:

```bash
sudo chmod 3775 /srv/devshare
```

---

## جمع‌بندی

مدل مجوزهای لینوکس ابزار قدرتمندی برای حفظ امنیت و سازمان‌دهی فایل‌ها است.
با درک مالکیت، بیت‌های ویژه و مجوزهای پیش‌فرض می‌توانیم دسترسی کاربران را دقیقاً مطابق نیاز تنظیم کنیم.
یادگیری استفادهٔ صحیح از `sudo` و `su` نیز به ما اجازه می‌دهد کارهای مدیریتی را بدون به خطر انداختن کل سیستم انجام دهیم.

در فصل بعد (فرایندها) خواهیم دید چگونه سیستم یونیکس اجرای برنامه‌ها را مدیریت می‌کند و چگونه کاربران می‌توانند آن‌ها را کنترل کنند.
