# فصل ۸ – ترفندهای پیشرفتهٔ صفحه‌کلید

---

## مقدمه

تا این‌جا یاد گرفته‌ایم چگونه دستورات را تایپ و اجرا کنیم، خروجی‌ها را هدایت کنیم و رفتار شل را با گسترش‌ها کنترل کنیم.
اما اگر هنگام تایپ اشتباه کنیم، بخواهیم دوباره دستوری طولانی را ویرایش کنیم یا می‌خواهیم از تاریخچهٔ فرمان‌ها بهره ببریم چه؟
خوشبختانه bash (و به طور کلی کتابخانهٔ `readline` که برای خواندن ورودی از صفحه‌کلید استفاده می‌شود) مجموعه‌ای عظیم از میان‌بُرهای صفحه‌کلید را در اختیارمان می‌گذارد تا تجربهٔ خط فرمان بسیار راحت‌تر و سریع‌تر شود.

در این فصل می‌خوانیم:

* چگونه با میان‌بُرهای حرکتی، مکان‌نمای خط فرمان را به سرعت جابه‌جا کنیم.
* روش‌های ویرایش و اصلاح متون بدون نیاز به پاک کردن تمام خط.
* تکنیک‌های «بُرش و چسباندن» متن به کمک حافظهٔ موقت (kill-ring).
* تکمیل خودکار دستورها، مسیرها و متغیرها با کلید `Tab` و حالت‌های مختلف آن.
* استفادهٔ مؤثر از تاریخچهٔ فرمان‌ها، جست‌وجوی تعاملی و فراخوانی مجدد دستورات قدیمی.

---

## ویرایش خط فرمان

کتابخانهٔ `readline` که مسئول خواندن ورودی از صفحه‌کلید است، یک حالت «ویرایش امکانی» فراهم می‌کند.
این یعنی می‌توانیم درست مانند یک ویرایشگر متن کوچک، درون خط فرمان حرکت کنیم، حروف را حذف و اضافه کنیم و حتی قطعه‌ای از متن را جابه‌جا کنیم.

بسیاری از کلیدهای میان‌بر مبتنی بر کنترل (`Ctrl`) یا متا (`Alt` یا `Esc`) هستند.
در جدول‌های زیر، نماد `C-` به معنی نگه داشتن کلید `Ctrl` و سپس فشردن کلید بعدی است؛ `M-` نیز برای `Alt` یا `Meta` استفاده می‌شود.
اگر صفحه‌کلید شما کلید `Alt` ندارد می‌توانید ابتدا `Esc` را بفشارید و سپس کلید دوم را بزنید.

### جابه‌جایی مکان‌نما

| کلید | توضیح |
| ---- | ----- |
| `C-a` | رفتن به ابتدای خط (مانند Home). |
| `C-e` | رفتن به انتهای خط. |
| `C-f` | حرکت یک نویسه به جلو (معادل فلش راست). |
| `C-b` | حرکت یک نویسه به عقب (معادل فلش چپ). |
| `M-f` | رفتن به ابتدای واژهٔ بعدی. |
| `M-b` | رفتن به ابتدای واژهٔ قبلی. |
| `C-l` | پاک‌سازی صفحه و قرار دادن خط جاری در بالای صفحه (معادل `clear`). |

### ویرایش و اصلاح متن

| کلید | توضیح |
| ---- | ----- |
| `C-d` | حذف نویسهٔ زیر مکان‌نما. |
| `C-h` | حذف نویسهٔ قبل از مکان‌نما (مثل Backspace). |
| `M-d` | حذف از مکان‌نما تا انتهای واژهٔ جاری. |
| `M-Backspace` | حذف واژهٔ پیش از مکان‌نما. |
| `C-t` | جابه‌جایی دو نویسهٔ مجاور. |
| `M-t` | جابه‌جایی دو واژهٔ مجاور. |
| `M-u` | تبدیل واژهٔ پس از مکان‌نما به حروف بزرگ. |
| `M-l` | تبدیل واژهٔ پس از مکان‌نما به حروف کوچک. |
| `M-c` | تبدیل حرف نخست واژهٔ بعدی به حروف بزرگ. |

بسیاری از این حرکات در حالت Emacs نیز وجود دارند؛ اگر با آن محیط آشنا باشید، حس راحتی خواهید داشت.

### برش، کپی و چسباندن

`readline` مفهومی به نام kill-ring دارد که مشابه کلیپ‌بورد عمل می‌کند.
با میان‌برهای «kill» بخشی از خط را حذف می‌کنیم و در عین حال در حافظه نگه می‌داریم تا بعداً با «yank» آن را بازگردانیم.

| کلید | توضیح |
| ---- | ----- |
| `C-k` | حذف از مکان‌نما تا انتهای خط. |
| `M-k` | حذف از مکان‌نما تا پایان جمله (نقطه، ! یا ?). |
| `C-u` | حذف از ابتدای خط تا مکان‌نما. |
| `C-w` | حذف واژهٔ قبل از مکان‌نما. |
| `M-w` | کپی واژهٔ قبل از مکان‌نما بدون حذف. |
| `C-y` | چسباندن آخرین متن حذف‌شده (yank). |
| `M-y` | در صورت تکرار پس از `C-y`، متن حذف‌شدهٔ قبلی را برمی‌گرداند (گردش میان kill-ring). |

Kill-ring در طول نشست شل فعال است، بنابراین می‌توانید متن حذف‌شده را در دستوری دیگر بازگردانید.

### لغو و تکرار

| کلید | توضیح |
| ---- | ----- |
| `C-_` یا `C-x C-u` | لغو آخرین تغییر (Undo). |
| `M-r` | بازنشانی متن خط به حالت اولیهٔ ذخیره‌شده در تاریخچه. |

---

## تکمیل خودکار (Tab Completion)

bash قادر است بسیاری از مقادیر را پس از تایپ چند نویسه و فشردن `Tab` حدس بزند.
این ویژگی نه‌تنها سرعت تایپ را افزایش می‌دهد، بلکه از خطاهای تایپی جلوگیری می‌کند.

* **تکمیل نام برنامه‌ها**: هنگام تایپ نام دستور، فشردن `Tab` آن را کامل می‌کند یا فهرست گزینه‌های ممکن را نمایش می‌دهد.
* **تکمیل مسیر فایل‌ها**: اگر مسیر نسبی یا مطلقی را آغاز کنیم، `Tab` آن را تا جایی که مبهم نباشد کامل می‌کند.
* **تکمیل متغیرها، نام‌های کاربری و میزبان**: با نگارش مناسب (`$`, `~`, `@`) می‌توانیم این موارد را نیز کامل کنیم.

اگر بیش از یک گزینهٔ ممکن وجود داشته باشد، bash با دوبار فشار دادن `Tab` فهرستی از گزینه‌ها را نشان می‌دهد.
همچنین برخی توزیع‌ها بستهٔ «bash-completion» را فعال می‌کنند که تکمیل‌های هوشمند برای برنامه‌هایی مانند `git`, `ssh` و `tar` فراهم می‌کند.

می‌توانید با دستور `bind -P` همهٔ میان‌برهای در حال استفاده را ببینید یا با `bind "TAB:menu-complete"` رفتار `Tab` را به حالت منو تغییر دهید تا هر بار فشردن آن گزینهٔ بعدی را انتخاب کند.

---

## تاریخچهٔ فرمان‌ها

هر بار که دستوری را اجرا می‌کنیم، bash آن را در فایل `~/.bash_history` ذخیره می‌کند (مگر این‌که تنظیمات دیگری اعمال شده باشد).
با این ویژگی می‌توانیم دستورات گذشته را دوباره فراخوانی کنیم، ویرایش کنیم یا به عنوان الگو برای فرمان‌های جدید استفاده کنیم.

### پیمایش تاریخچه

| کلید | توضیح |
| ---- | ----- |
| `C-p` یا فلش بالا | رفتن به دستور قبلی. |
| `C-n` یا فلش پایین | رفتن به دستور بعدی. |
| `M-<` | رفتن به قدیمی‌ترین دستور. |
| `M->` | رفتن به جدیدترین دستور. |

همچنین می‌توانیم با دستور `history` فهرست تاریخچه را ببینیم:

```bash
history | tail
```

عدد ابتدای هر خط «شمارهٔ تاریخچه» است که می‌توانیم برای فراخوانی سریع دستور استفاده کنیم.

### اجرای مجدد دستورات

* `!!` : اجرای آخرین دستور.
* `!n` : اجرای دستوری که شمارهٔ تاریخچهٔ آن `n` است.
* `!-n` : اجرای دستوری که `n` خط قبل اجرا شده است.
* `!string` : اجرای جدیدترین دستوری که با `string` آغاز شده است.

پیش از اجرای دستور، bash آن را چاپ می‌کند تا بتوانیم بررسی کنیم.
با استفاده از `set -o histverify` می‌توانیم کاری کنیم که شل دستور بازبینی‌شده را در خط فرمان قرار دهد تا قبل از اجرا در صورت نیاز ویرایش کنیم.

### جست‌وجوی تعاملی

اگر `C-r` را فشار دهیم، bash وارد حالت «جست‌وجوی معکوس» می‌شود.
با تایپ چند نویسه، شل در تاریخچهٔ ما به دنبال نزدیک‌ترین تطابق می‌گردد.

* `C-r` را چندبار پشت سر هم بزنید تا به جست‌وجوی تطابق‌های قبلی ادامه دهد.
* با `C-s` می‌توانید در جهت رو به جلو جست‌وجو کنید (اگر در ترمینال فعال باشد).
* با `Enter` دستور یافته اجرا می‌شود و با `C-y` می‌توان آن را روی خط فرمان گذاشت بدون اجرا.
* برای خروج از حالت جست‌وجو بدون تغییری، `C-g` یا `Esc` را فشار دهید.

### تنظیمات تاریخچه

رفتار تاریخچه را می‌توان با متغیرهای محیطی کنترل کرد:

* `HISTSIZE` : تعداد خطوطی که در حافظهٔ نشست نگهداری می‌شود.
* `HISTFILESIZE` : تعداد خطوط مجاز در فایل تاریخچه.
* `HISTCONTROL` : می‌تواند مقادیری مانند `ignoredups` (نادیده گرفتن دستورات تکراری) یا `ignorespace` (نادیده گرفتن دستورات آغاز شده با فاصله) داشته باشد.
* `HISTIGNORE` : الگوهایی که باید در تاریخچه ذخیره نشوند.

برای اعمال تنظیمات، آن‌ها را در `~/.bashrc` خود قرار دهید:

```bash
export HISTCONTROL="ignoredups:ignorespace"
export HISTSIZE=5000
```

---

## اجرای مجدد و ویرایش دستورات در ویرایشگر خارجی

گاهی ویرایش یک دستور بسیار طولانی در خود خط فرمان دشوار است.
bash دستور `fc` را ارائه می‌دهد که آخرین دستور را در یک ویرایشگر متنی باز می‌کند، اجازه می‌دهد آن را اصلاح کنیم و سپس اجرا می‌کند.

```bash
fc                # باز کردن دستور قبلی در ویرایشگر پیش‌فرض
fc -l 20 30       # نمایش دستورات شماره ۲۰ تا ۳۰
fc -s old=new     # جایگزینی old با new در دستور قبلی و اجرا
```

ویرایشگر پیش‌فرض با متغیر محیطی `FCEDIT` یا `EDITOR` مشخص می‌شود.
اگر ترجیح می‌دهید همیشه از برنامه‌ای مانند `vim` یا `nano` استفاده کنید، آن را در تنظیمات پوسته تعریف کنید.

---

## شخصی‌سازی میان‌برها

با دستور `bind` می‌توانیم میان‌برهای جدید تعریف کنیم یا موجودها را تغییر دهیم.
برای نمونه، اگر بخواهیم `C-j` مانند `Enter` عمل کند، می‌توانیم بگوییم:

```bash
bind '"\C-j":accept-line'
```

همچنین امکان بارگذاری فایل `~/.inputrc` وجود دارد که مجموعه‌ای از نگاشت‌های دلخواه را برای همهٔ برنامه‌های مبتنی بر `readline` (مانند `bash`, `ftp`, `python` و غیره) اعمال می‌کند.

نمونه‌ای از `~/.inputrc`:

```
set editing-mode vi
set completion-ignore-case on
"\e[A": history-search-backward
"\e[B": history-search-forward
```

خط نخست حالت ویرایش را به سبک `vi` تغییر می‌دهد؛ در این حالت باید با کلید `Esc` وارد حالت فرمان شوید و با `i` یا `a` ویرایش را آغاز کنید.
دو خط بعدی ترتیب جست‌وجو در تاریخچه را به گونه‌ای تغییر می‌دهد که با تایپ چند نویسه و فشردن فلش بالا/پایین فقط دستورات دارای همان پیشوند مرور شوند.

---

## جمع‌بندی

یادگیری چند میان‌بر کلیدی می‌تواند سرعت کار شما را چند برابر کند.
به جای پاک کردن کامل خطوط طولانی، می‌توانید با چند حرکت ساده آن‌ها را اصلاح کنید، از تاریخچه بهره بگیرید و با تکمیل خودکار از اشتباهات جلوگیری نمایید.

در فصل بعد به موضوع مهم «مجوزها و مالکیت فایل‌ها» می‌پردازیم که زیرساخت امنیتی سیستم فایل‌های یونیکسی را تشکیل می‌دهد.
